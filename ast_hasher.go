// Copyright 2020 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

package copyist

import (
	"crypto/md5"
	"encoding/binary"
	"fmt"
	"go/ast"
	"reflect"
)

// hashValue is an MD5 hash type (16 bytes).
type hashValue [md5.Size]byte

// astHasher computes MD5 hashes for AST trees, by walking the tree in prefix
// order and serializing it as bytes over which the hash is computed. Hashes
// over AST nodes are useful during code generation, as they enable copyist to
// detect when multiple tests can share identical records. Only AST nodes
// generated by copyist are handled; if the hasher encounters other node types,
// it will panic.
//
// To use astHasher, construct an instance and then call HashAstNode. Try to
// reuse astHasher, as it will reuse a byte buffer across calls.
type astHasher struct {
	buf []byte
}

// HashAstNode returns an MD5 hash value for the given AST tree. This hash has
// a vanishingly low probability of collision with other AST trees that are
// different. Therefore, if two AST nodes have the same hash, then they can be
// considered to be identical trees without further checks.
func (h *astHasher) HashAstNode(nd ast.Node) hashValue {
	h.writeAstNode(nd)
	val := md5.Sum(h.buf)
	h.buf = h.buf[:0]
	return val
}

func (h *astHasher) writeAstNode(nd ast.Node) {
	if nd == nil {
		h.hashUint64(0)
		return
	}

	// Write ast nodes using prefix notation - start with type of node.
	h.hashUint64(uint64(reflect.ValueOf(reflect.TypeOf(nd)).Pointer()))

	switch t := nd.(type) {
	case *ast.ArrayType:
		h.writeAstNode(t.Len)
		h.writeAstNode(t.Elt)
	case *ast.BasicLit:
		h.writeUint32(uint32(t.Kind))
		h.writeString(t.Value)
	case *ast.CallExpr:
		h.writeAstNode(t.Fun)
		h.writeAstExprSlice(t.Args)
	case *ast.CompositeLit:
		h.writeAstNode(t.Type)
		h.writeAstExprSlice(t.Elts)
	case *ast.ExprStmt:
		h.writeAstNode(t.X)
	case *ast.Ident:
		h.writeString(t.Name)
		if t.Obj != nil {
			panic("non-nil ast.Ident.Obj is not handled")
		}
	case *ast.KeyValueExpr:
		h.writeAstNode(t.Key)
		h.writeAstNode(t.Value)
	case *ast.SelectorExpr:
		h.writeAstNode(t.X)
		h.writeAstNode(t.Sel)
	case *ast.UnaryExpr:
		h.writeUint32(uint32(t.Op))
		h.writeAstNode(t.X)
	default:
		// astHasher only handles node types generated by copyist.
		panic(fmt.Sprintf("unhandled AST type for hashing: %T", nd))
	}
}

func (h *astHasher) writeAstExprSlice(exprs []ast.Expr) {
	h.writeUint32(uint32(len(exprs)))
	for _, e := range exprs {
		h.writeAstNode(e)
	}
}

func (h *astHasher) writeString(val string) {
	h.writeUint32(uint32(len(val)))
	buf := h.allocBytes(len(val))
	copy(buf, val)
}

func (h *astHasher) writeUint32(val uint32) {
	binary.LittleEndian.PutUint32(h.allocBytes(4), val)
}

func (h *astHasher) hashUint64(val uint64) {
	binary.LittleEndian.PutUint64(h.allocBytes(8), val)
}

func (h *astHasher) allocBytes(cnt int) []byte {
	l := len(h.buf)
	if l+cnt > cap(h.buf) {
		newBuf := make([]byte, l+cnt, (l+cnt)*3/2)
		copy(newBuf, h.buf)
		h.buf = newBuf
	} else {
		h.buf = h.buf[:l+cnt]
	}
	return h.buf[l : l+cnt]
}
